---
layout: ru/blogs/239/2021/post
title:  "Урок 2: двумерный вектор"
date:   2021-09-15 00:02:00 +0300
lang:   ru
categories: school239_11_2021_2022
---

Так мы работали с обычным динамическим вектором из целых чисел:

```c++
std::vector<int> xs;
xs.push_back(10); // добавит число в конец вектора (тем самым динамически увеличив его на один элемент)
xs.push_back(20);
xs.push_back(30);
rassert(xs.size() == 3, 351251512); // проверка что размер теперь стал 3, число в конце - уникальный код ошибки который я настучал на клавиатуре
std::cout << xs.size() << std::endl; // выведет размер - 3
```

Альтернативно можно сразу изменить размер вектора:

```c++
int n;
std::cin >> n; // считали число из консоли

std::vector<int> xs;
xs.resize(n); // сразу изменили размер вектора
rassert(xs.size() == n, 563565676);
for (int i = 0; i < n; ++i) {
    xs[i] = i; // заполнили его числами от 0 до (n-1)
}
rassert(xs.size() == n, "size of vector should be still n!"); // вместо случайного кода ошибки можно писать текст ошибки - размер вектора все еще должен быть n
```

А что если мы хотим работать с картинками? Можно было бы представить себе картинку как таблицу, как матрицу, или как вектор в котором каждый элемент - это вектор хранящий числа из одной строчки:

![Image table](/static/2021/09/08/board2.png)

Поэтому хорошо бы научиться работать с вектором хранящим вектора каждый из которых хранит числа:

```c++
int cols; // число рядов (строчек) в таблице (т.е. ее высота)
int rows; // число колонок в таблице (т.е. ее ширина)

std::cout << "Please enter WIDTH (cols) and HEIGHT (rows) of a table:" << std::endl;
std::cin >> cols >> rows; // считали оба числа из консоли

std::vector<std::vector<int>> table; // эта двумерная таблица - просто вектор из векторов 
for (int j = 0; j < rows; ++j) { // создаем каждый ряд таблицы
    std::vector<int> row; // создаем очередной ряд
    row.resize(cols); // его размер - число колонок в таблице
    table.push_back(row); // не забываем добавить ряд в конец таблицы (тем самым увеличив ее высоту)
}
int valueAtJRowAndIColumn = table[j][i]; // этот код позволяет обратиться к элементу в j-ой строчке (ряду) и i-ом столбце (колонке)
```

Чтобы получить новое задание - надо обновить вашу копию (клон который вы ответвили) репозитория с исходниками:

1) Откройте свой аккаунт на [github.com](https://github.com/) и откройте список своих репозиториев (Repositories) найдите там ```CPPExercises2021```

2) Откройте Pull requests -> New pull request

3) В строчке с четырьмы выпадающими списками в **head repository** укажите ```PML239CVCourse/CPPExercises2021```

4) Теперь нажмите синее **compare across forks** -> убедитесь что **head repository** так же ```PML239CVCourse/CPPExercises2021```

6) В выпадающем списке **base repository** укажите ваш репозиторий ```MyUserName/CPPExercises2021```

7) Проверьте что снизу появилось что-то в т.ч. про **lesson02** и **lesson02vector**

8) Нажмите зеленую кнопку ```Create pull request``` -> ```Create pull request``` -> ```Merge pull request``` -> ```Confirm merge```

9) Убедитесь что в вашем репозитории ```CPPExercises2021``` появилась папка **lesson02**

10) Откройте CLion и нажмите там ```Git->Update Project...``` (или Ctrl+T) -> выберите ```Rebase ...``` -> ```Ok```

11) Убедитесь что у вас появилась папка **lesson02**

12) Внутри есть **TODO** - выполняйте их по возрастанию номеров (они разбиты на три группы)

13) Чтобы запустить новую программу вместо старой (вместо прошлого урока) - нажмите сверху справа на выпадающий список ```hello | Debug``` рядом с зеленым треугольником запуска и выберите там ```lesson02vector```, затем нажмите на зеленый треугольник запуска

14) В конце урока и когда дома доделаете задание - не забудьте сделать Commit+Push - см. **Сохраняйте в репозитории изменения** из прошлой инструкции
