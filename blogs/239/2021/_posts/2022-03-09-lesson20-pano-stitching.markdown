---
layout: ru/blogs/239/2021/post
title:  "Урок 20: сшивка панорамы по шву найденному быстрой Дейкстрой"
date:   2022-03-09 00:02:00 +0300
lang:   ru
categories: school239_11_2021_2022
---

Пусть мы взяли две картинки:

![Panorama pair](/static/2022/03/diff/pano1_hanging.png)

Пусть мы **поняли насколько отличаются их цвета в одном и том же пикселе:**

![Panorama diff](/static/2022/03/diff/pano1_diff_hanging.jpg)

Давайте проложим кратчайший путь по этой карте различий из нижнего левого угла всего пространства панорамы в верхний левый угол:

![Panorama dijkstra seam](/static/2022/03/seam/5panoOptimalSeam.jpg)

Что нам для этого надо учесть? Как свести задачу к Дейкстре из прошлого задания?

 - Давайте максимально приблизим к решению из задания про "найти выход в лабиринте-картинке"

 - Достаточно создать картинку-лабиринт (см. функцию ```buildTheMaze(...)```) из нашей картинки **насколько отличаются их цвета в одном и том же пикселе**

 - А в пикселях лабиринта где хотя бы одна из наложенных картинок отсутствует (т.е. ```isPixelEmpty(...)```, т.е. черный пиксель) - скажем что цена прохождения очень высокая - например ```const int BIG_PENALTY = 100000;```

 - После чего (см. функцию ```findBestSeam(...)```) из каждого пикселя давайте проведем ребро вверх и ребро вправо с длинной равной значению содержащемуся в пикселе лабиринта

 - И наконец найдем Дейкстрой кратчайший путь из вершины ```start``` соответствующей нижнему левому углу всего пространства панорамы, в вершину ```finish``` соответствующую верхнему правому углу всей панорамы

Теперь надо как-то построить красивую панораму так чтобы все что слева от этого шва - было взято из первой картинки, а все что справа от этого шва - было взято из правой картинки.

Давайте визуализируем и построим для начала такую картинку - в каждом пикселе черный цвет (```NO_DATA = 0```) если этого пикселя нет ни на одной картинке, темно-серый (```PIXEL_FROM_PANO0 = 100```) если этот пиксель должен быть взят с первой картинки, светло-серый (```PIXEL_FROM_PANO1 = 200```) если со второй:

![Panorama image source id](/static/2022/03/seam/6sourceId.jpg)

Как построить такую картинку? Давайте начнем с того чтобы заполнить всю картинку ```NO_DATA```, затем с помощью поиска в ширину заполним пиксели относящиеся к первой картинке (т.е. ```PIXEL_FROM_PANO0```):

1) Изначально отметим все пиксели как ```NO_DATA```

2) Заполним все пиксели принадлежащие шву значением ```PIXEL_IS_ON_SEAM = 1```

3) Давайте воспользуемся поиском в ширину (**BFS**)

4) Отметим верхний левый пиксель как ```PIXEL_FROM_PANO0``` и добавим его в текущую волну распространения (```curWave```)

5) Выполняем в цикле ```while``` до тех пока в текущей волне распространения (```curWave```) есть хотя бы один пиксель:

5.1) Смотрим на каждый пиксель из текущей волны распространения и смотрим в цикле на каждый из четырех соседей (слева, сверху, справа, снизу)

5.2) Если сосед (**n**eighbor - сосед, поэтому пусть ```nx, ny```) за пределами картинки - ничего с ним не делаем

5.3) Если сосед пуст в первой картинке - в него тоже не надо распространять влияние первой картинки - ничего с ним не делаем

5.4) Если это пиксель лежащий на шве (```PIXEL_IS_ON_SEAM```) - в него тоже не надо распространять влияние первой картинки - ничего с ним не делаем

5.5) Если это пиксель который уже принадлежащий первой картинке (```PIXEL_FROM_PANO0```) - ничего с ним не делаем

5.6) Иначе - отмечаем соседний пиксель ```nx, ny``` как принадлежащий первой картинке (```PIXEL_FROM_PANO0```) и добавляем его в следующую волну обработки ```nextWave```

5.7) Когда мы обработали все пиксели текущей волны - новая волна готова, берем ее вместо текущей: ```curWave = nextWave;```

6) Все остальные пиксели заполняем со второй картинки (т.е. все кто не ```PIXEL_FROM_PANO0``` и при этом не пуст на второй картинке)

Наконец давайте сделаем красивую панораму с учетом этой картинки указывающей откуда какую картинку брать:

![Panorama stitched result](/static/2022/03/seam/7newPano.jpg)

Как это сделать? пройти по всем пикселям, посмотреть из какой картинки брать цвет - и взять соответственно :)
