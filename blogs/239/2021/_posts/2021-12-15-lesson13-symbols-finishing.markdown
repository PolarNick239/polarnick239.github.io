---
layout: ru/blogs/239/2021/post
title:  "Урок 13: Распознавание букв - мелочи"
date:   2021-12-15 00:02:00 +0300
lang:   ru
categories: school239_11_2021_2022
---

Идеи/советы
======

1) Чтобы перенести реализацию построения HoG из позапрошлого урока в предыдущий урок в котором было реализовано разбиение картинки на буквы - казалось бы достаточно скопировать ваш [hog.h хэдер с декларацией](https://github.com/PML239CVCourse/CPPExercises2021/blob/main/lesson10/src/hog.h) и [hog.cpp файл с реализацией](https://github.com/PML239CVCourse/CPPExercises2021/blob/main/lesson10/src/hog.cpp) в папку прошлого урока [рядом с parseSymbols.h и parseSymbols.cpp](https://github.com/PML239CVCourse/CPPExercises2021/tree/main/lesson11/src).

И да, это очень хорошая идея - осталось дело за малым - подсказать компилятору что этот файл надо компилировать в рамках проекта, давайте посмотрим как это было проделано для [parseSymbols.h и parseSymbols.cpp](https://github.com/PML239CVCourse/CPPExercises2021/blob/main/lesson11/CMakeLists.txt#L13-L14) и сделаем по аналогии и для hog.h + hog.cpp.

2) Как упорядочить буквы? Для начала просто отсортировать их по оси x - воспользуйтесь ```std::sort```, а чтобы узнать как сформулировать критерий сортировки (оператор сравнения объектов) - загуглите ```cpp how to sort vector of custom objects```.

3) Как упорядочить буквы по несколько строк? Например так:

 - Отсортируем все буквы по оси y. Разобъем их на группы по принципу "пока координата y между соседними буквами отличается меньше чем на число пикселей соответствующее типовой букве - добавляем буквы в один список, если произошел резкий скачек y - мы накапливаем новую строчку букв".
 - Затем в каждой группе "строчка букв" проводим независимую сортировку по оси x.

4) Как получить лучший результат?

 - Попробовать увеличить число корзин в HoG
 - Добавить интерполяцию голосов (добавлять не только в "ближайшую корзину", но сразу в две корзины - пропорционально тому насколько какая из них ближе, как было с пространством Хафа)
 - Попробовать строить не один HoG на всю букву - а, учтя проблемы с ```b-p``` и ```q-d```, рассекать букву на две части - верхняя половина и нижняя половина, и строить HoG для каждой части независимо, а затем клеить эти два HoG (по сути два вектора) в один HoG (по сути один вектор, но в два раза более длинный)

5) Попробовать реализовать другой метод: https://zen.yandex.ru/media/id/5d9846210ce57b00ae024387/raspoznavanie-simvolov-bez-neiroseti-5e12f0da98930900b3abd07f
