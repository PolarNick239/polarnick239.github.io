---
layout: ru/blogs/courses/Sirius26CVPuzzleSolver/post
title:  "Занятия 4: Найдем контура и углы объектов"
date:   2026-01-10 12:31:40 +0300
lang:   ru
categories: Sirius26CVPuzzleSolver
---

Мем
===

![Prompt Engineer VS Sloperator meme](/static/2026/01/auf_robots_meme.jpg)

Что уже есть
===

![Downscaled photo of puzzle example](/static/2026/01/downscaled_photo_example.jpg)

Разбиваем на куски
===

Теперь благодаря морфологии с прошлого занятия мы получили чистую маску:

![Good foreground mask after morphology](/static/2026/01/mask_good.png)

В каждом куске находим границы
===

Подумайте, **как можно найти координаты пикселей на периметре** куска (причем упорядоченными - чтобы они сформировали цикл из пикселей):

![Good foreground mask after morphology](/static/2026/01/object_border.png)

Как решить эту задачу? В два шага:
1) Строим новую маску - множество пикселей лежащих на периметре (по простому критерию - среди 8 соседей должны быть либо 1 либо 2 пикселя с фона)

2) Эту новую маску обходим чем-то вроде поиска в ширину, но чтобы сохранять направление - выбираем среди соседей того что сохраняет моментум движения - то есть если предыдущий шаг был например направо, то и новый шаг должен быть как можно ближе к этому направлению

В каждом куске находим четыре стороны
===

А если у нас есть цикл из этих пикселей-вершин, то **как разбить их на четыре множества** - четыре стороны куска:

![Good foreground mask after morphology](/static/2026/01/object_4sides.png)

Чего мы хотим
===

Взяв маску делящую картинку на объект и фон - вытащить отдельные объекты и каждый независимо обработать:

1) В каждом объекте выделить контур (периметр границы ввиде цепочки координат)
2) Через упрощение этого контура определить какие вершины были угловыми
3) ???
4) Вы восхитительны - теперь вы знаете четыре цепочки пикселей являющихся стороной кусочка пазла

Выводы
===

- **Не запускал - не работает** - если код не запускали, то он скорее-всего работает неверно, а может быть даже не компилируется



Практика разбиение картинки на отдельные картинки-объекты
===

```Задание 1.1``` [Обновите свой fork](/blogs/courses/sirius26cvpuzzlesolver/2026/01/08/3fork.html#%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D0%B4%D1%82%D1%8F%D0%BD%D1%83%D1%82%D1%8C-%D0%BC%D0%BE%D0%B8-%D0%BD%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%B2%D0%B0%D1%88-fork) репозиторий, убедитесь что у вас все компилируется, запустите юнит-тесты **All CTest**: 

![Run All CTest](/static/2026/01/run_all_ctest.png)

```Задание 1.2``` Заметьте что падает два набора юнит-тестов - те что проверяют функцию ```buildContourMask()``` и ```simplifyContour()``` - их вам нужно будет **самостоятельно** реализовать!

```Задание 2.1``` Запустите CVPuzzleSolver (выбрав сверху его вместо **All CTest**) - проверьте что результаты в debug вам нравятся и все хорошо работает. Программа будет падать с ```Error: Function buildContourMask() is not implemented!``` т.к. нужно будет реализовать две функции. Проверьте что построенный вами контур для каждого объекта выглядит хорошо.

```Задание 2.2``` У нас уже есть бинарная маска делящая фото на пиксели объекта и фона. Теперь нам нужно обработать каждый кусочек картинки. Для каждого кусочка постройте маску контура а затем и ```std::vector<point2i>``` - точки с контура. Проверьте через отладочные debug-визуализации. Теперь вам надо реализовать функцию занимающуюся упрощением геометрии. Проверьте что визуально она строит стороны правильно (цветная раскраска очень помогает):

```buildContourMask()``` (в ```libs/images/libimages/algorithms/extract_contour.cpp```) - реализуйте эту функцию, постройте маску пикселей лежащих на периметре

```simplifyContour()``` (в ```libs/images/libimages/algorithms/simplify_contours.cpp```) - реализуйте эту функцию, то есть удаляйте самые не-угловатые вершины из контура до тех пор пока не останется четыре угловые вершины

```Задание 3``` Ознакомьтесь с [ускорением через OpenMP](/blogs/courses/sirius26cvpuzzlesolver/2026/01/10/30-cpu-parallelism-openmp.markdown) - запустите код и исследуйте - во сколько раз ускоряется морфология на вашем компьютере? Какое ускорение вы бы ожидали? Сколько ядер у вашего CPU? Какое ускорение вы пронаблюдали на практике? Попробуйте запустить несколько раз для надежности. Попробуйте ускорить обработку объектов - чтобы обработка одного объекта работала на отдельном ядре.

К следующему занятию
===

```Задание 4``` Подумайте, теперь мы знаем где границы каждого куска. Как теперь попробовать для каждой границы найти самую похожую на нее границу какого-то другого куска? Как измерить что такое "самая похожая"?
