---
layout: ru/blogs/courses/Sirius26CVPuzzleSolver/post
title:  "Занятия 4: Найдем контура и углы объектов"
date:   2026-01-10 12:31:40 +0300
lang:   ru
categories: Sirius26CVPuzzleSolver
---

Мем
===

![Prompt Engineer VS Sloperator meme](/static/2026/01/auf_robots_meme.jpg)

Что уже есть
===

![Downscaled photo of puzzle example](/static/2026/01/downscaled_photo_example.jpg)

Разбиваем на куски
===

Теперь благодаря морфологии с прошлого занятия мы получили чистую маску:

![Good foreground mask after morphology](/static/2026/01/mask_good.png)

Как посчитать сколько у нас объектов? Как извлечь каждый объект чтобы работать с ним отдельно?

![Objects with bboxes](/static/2026/01/objects_with_bboxes.jpg)

Нам поможет Система Непересекающихся Множеств! (СНМ, Disjoint Set)

Подробнее можно [почитать тут](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%9D%D0%9C_%28%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BB%D0%B5%D1%81%D0%B0_%D0%BA%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D1%8B%D1%85_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D0%B5%D0%B2%29)
или [послушать тут.](https://youtu.be/_n_c3bohuU4?t=4058)

То есть хочется извлечь каждый объект - его картинку + его маску + его координаты в оригинальной картинке:

![Extracted object with mask](/static/2026/01/extracted_object_with_mask.png)

В каждом куске находим границы
===

Подумайте, **как можно найти координаты пикселей на периметре** куска (причем упорядоченными - чтобы они сформировали цикл из пикселей):

![Good foreground mask after morphology](/static/2026/01/object_border.png)

Как решить эту задачу? В два шага:

1) Строим новую маску - множество пикселей лежащих на периметре (по простому критерию - среди 8 соседей должны быть и пиксели с фона, и пиксели объекта)

2) Эту новую маску обходим чем-то вроде поиска в ширину, но чтобы сохранять направление - выбираем среди соседей того что сохраняет моментум движения - то есть если предыдущий шаг был например направо, то и новый шаг должен быть как можно ближе к этому направлению

В каждом куске находим четыре стороны
===

А если у нас есть цикл из этих пикселей-вершин, то **как разбить их на четыре множества** - четыре стороны куска:

![Good foreground mask after morphology](/static/2026/01/object_4sides.png)

Чего мы хотим
===

Взяв маску делящую картинку на объект и фон - вытащить отдельные объекты и каждый независимо обработать:

1) В каждом объекте выделить контур (периметр границы ввиде цепочки координат)

2) Через упрощение этого контура определить какие вершины были угловыми

3) Разбить контур на четыре части (четыре стороны объекта) по угловым вершинам

4) ???

5) Вы восхитительны - теперь вы знаете четыре цепочки пикселей являющихся стороной кусочка пазла

Практика
===

```Задание 1.1``` [Обновите свой fork](/blogs/courses/sirius26cvpuzzlesolver/2026/01/08/3fork.html#%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D0%B4%D1%82%D1%8F%D0%BD%D1%83%D1%82%D1%8C-%D0%BC%D0%BE%D0%B8-%D0%BD%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%B2%D0%B0%D1%88-fork) репозиторий, убедитесь что у вас все компилируется, запустите юнит-тесты **All CTest**: 

![Run All CTest](/static/2026/01/run_all_ctest.png)

```Задание 1.2``` Заметьте что падает два набора юнит-тестов - те что проверяют функцию ```buildContourMask()``` и ```simplifyContour()``` - их вам нужно будет **самостоятельно** реализовать!

```Задание 2.1``` Запустите CVPuzzleSolver (выбрав сверху его вместо **All CTest**) - проверьте что результаты в debug вам нравятся и все хорошо работает. Программа будет падать с ```Error: Function buildContourMask() is not implemented!``` т.к. нужно будет реализовать две функции. Проверьте что построенный вами контур для каждого объекта выглядит хорошо.

```Задание 2.2``` У нас уже есть бинарная маска делящая фото на пиксели объекта и фона. Теперь нам нужно обработать каждый кусочек картинки. Для каждого кусочка постройте маску контура а затем и ```std::vector<point2i>``` - точки с контура. Проверьте через отладочные debug-визуализации. Теперь вам надо реализовать функцию занимающуюся упрощением геометрии. Проверьте что визуально она строит стороны правильно (цветная раскраска очень помогает):

```buildContourMask()``` (в ```libs/images/libimages/algorithms/extract_contour.cpp```) - реализуйте эту функцию, постройте маску пикселей лежащих на периметре

```simplifyContour()``` (в ```libs/images/libimages/algorithms/simplify_contours.cpp```) - реализуйте эту функцию, то есть удаляйте самые не-угловатые вершины из контура до тех пор пока не останется четыре угловые вершины

```Задание 3``` Ознакомьтесь с [ускорением через OpenMP](/blogs/courses/sirius26cvpuzzlesolver/2026/01/10/30-cpu-parallelism-openmp.html) - запустите код и исследуйте - во сколько раз ускоряется морфология на вашем компьютере? Какое ускорение вы бы ожидали? Сколько ядер у вашего CPU? Какое ускорение вы пронаблюдали на практике? Попробуйте запустить несколько раз для надежности. Попробуйте ускорить обработку объектов - чтобы обработка одного объекта работала на отдельном ядре.

К следующему занятию
===

```Задание 4``` Подумайте, теперь мы знаем где границы каждого куска. Как теперь попробовать для каждой границы найти самую похожую на нее границу какого-то другого куска? Как измерить что такое "самая похожая"?
