---
layout: ru/blogs/courses/Sirius26CVPuzzleSolver/post
title:  "OpenMP: Как ускорить алгоритм за счет многоядерности CPU"
date:   2026-01-10 12:30:00 +0300
lang:   ru
categories: Sirius26CVPuzzleSolver
---

Пусть есть код:

```cpp
for (int i = 0; i < n; ++i) {
    // do something w.r.t. i
}
```

Пусть алгоритм внутри цикла независимо обрабатывает разные индексы - то есть результат не меняется от того в каком порядке обрабатываются ```i```, и не меняется от того что они обрабатываются одновременно.

Тогда мы могли бы одновременно обрабатывать не просто какой-то один индекс ```i```, а столько параллельных значений ```i``` **сколько у вас ядер процессора** (CPU). А это линейное ускорение!

Для этого нужно ([см. коммит](https://github.com/CompVisionCourses/CVPuzzleSolver/commit/04e79607476b2d617f1c929f0e6037b9961ad67b))
1) подключить OpenMP библиотеку (на windows и linux является частью C++ компилятора, на macos бывают сложности)
2) добавить у этого цикла простое указание что он должен выполняться параллельно:

```cpp
#pragma omp parallel for
for (int i = 0; i < n; ++i) {
    // do something w.r.t. i
}
```

```Задание``` Попробуйте сделать это с морфологией - какое ускорение вы бы ожидали? Сколько ядер у вашего CPU? Какое ускорение вы пронаблюдали на практике? Попробуйте запустить несколько раз для надежности.
